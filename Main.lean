import Mathlib.Tactic.DeriveFintype
import Mathlib.Data.Fintype.Perm
import Mathlib.Data.Fintype.Prod

/-- A Cartesian axis in 3D space. -/
inductive Axis : Type
  /-- The `x` or left-right axis. -/
  | x : Axis
  /-- The `y` or bottom-top axis. -/
  | y : Axis
  /-- The `z` or back-front axis. -/
  | z : Axis

deriving instance DecidableEq, Fintype for Axis

namespace Axis

instance : Repr Axis := ‚ü®fun e _ ‚Ü¶ Std.Format.text <| match e with
  | Axis.x => "X"
  | Axis.y => "Y"
  | Axis.z => "Z"
‚ü©

protected theorem card : Fintype.card Axis = 3 :=
  rfl

/-- Permutes the `x`, `y`, `z` axes in cyclic order. -/
def rotate : Axis ‚Üí Axis
  | Axis.x => Axis.y
  | Axis.y => Axis.z
  | Axis.z => Axis.x

theorem rotate_ne : ‚àÄ a : Axis, a.rotate ‚â† a := by
  decide

@[simp]
theorem rotate_inj : ‚àÄ {a b : Axis}, a.rotate = b.rotate ‚Üî a = b := by
  decide

/-- Whether `b` is the next axis in cyclic order to `a`. -/
def IsNext (a b : Axis) : Prop :=
  a.rotate = b

instance : DecidableRel IsNext :=
  inferInstanceAs (‚àÄ a b : Axis, Decidable (a.rotate = b))

theorem isNext_irrefl (a : Axis) : ¬¨ IsNext a a :=
  rotate_ne a

@[simp]
theorem isNext_asymm_iff : ‚àÄ {a b}, a ‚â† b ‚Üí (¬¨ IsNext a b ‚Üî IsNext b a) := by
  decide

theorem IsNext.asymm (h : IsNext a b) : ¬¨ IsNext b a := by
  obtain rfl | hn := eq_or_ne b a
  ¬∑ exact isNext_irrefl b
  ¬∑ exact (isNext_asymm_iff hn).2 h

@[simp]
theorem isNext_rotate : ‚àÄ {a b}, IsNext a.rotate b.rotate ‚Üî IsNext a b := by
  decide

theorem IsNext.congr_left (hb : IsNext a b) (hc : IsNext a c) : b = c :=
  hb.symm.trans hc

theorem IsNext.congr_right (ha : IsNext a c) (hb : IsNext b c) : a = b :=
  rotate_inj.1 <| ha.trans hb.symm

/-- Given two distinct axes, returns the third. If both axes are equal, we just return it. -/
def other : Axis ‚Üí Axis ‚Üí Axis
  | Axis.x, Axis.y => Axis.z
  | Axis.x, Axis.z => Axis.y
  | Axis.y, Axis.x => Axis.z
  | Axis.y, Axis.z => Axis.x
  | Axis.z, Axis.x => Axis.y
  | Axis.z, Axis.y => Axis.x
  | Axis.x, Axis.x => Axis.x
  | Axis.y, Axis.y => Axis.y
  | Axis.z, Axis.z => Axis.z

@[simp]
theorem other_self : ‚àÄ a, other a a = a := by
  decide

@[simp]
theorem other_eq_left_iff : ‚àÄ {a b}, other a b = a ‚Üî a = b := by
  decide

@[simp]
theorem other_eq_right_iff : ‚àÄ {a b}, other a b = b ‚Üî a = b := by
  decide

theorem other_eq_iff : ‚àÄ {a b c}, a ‚â† b ‚Üí (other a b = c ‚Üî c ‚â† a ‚àß c ‚â† b) := by
  decide

theorem other_eq (h‚ÇÅ : a ‚â† b) (h‚ÇÇ : c ‚â† a) (h‚ÇÉ : c ‚â† b) : other a b = c :=
  (other_eq_iff h‚ÇÅ).2 ‚ü®h‚ÇÇ, h‚ÇÉ‚ü©

theorem other_ne_iff (h : a ‚â† b) : other a b ‚â† c ‚Üî c = a ‚à® c = b := by
  rw [‚Üê not_iff_not, not_ne_iff, other_eq_iff h, not_or]

theorem other_comm : ‚àÄ a b, other a b = other b a := by
  decide

theorem other_ne_left (h : a ‚â† b) : other a b ‚â† a :=
  ((other_eq_iff h).1 rfl).1

theorem other_ne_right (h : a ‚â† b) : other a b ‚â† b :=
  ((other_eq_iff h).1 rfl).2

@[simp]
theorem other_other_left : ‚àÄ {a b}, other (other a b) a = b := by
  decide

@[simp]
theorem other_other_right : ‚àÄ {a b}, other (other a b) b = a := by
  decide

@[simp]
theorem other_other_left' : other a (other a b) = b := by
  rw [other_comm, other_other_left]

@[simp]
theorem other_other_right' : other b (other a b) = a := by
  rw [other_comm, other_other_right]

@[simp]
theorem other_inj_left : ‚àÄ {a b c}, other c a = other c b ‚Üî a = b := by
  decide

@[simp]
theorem other_inj_right : other a c = other b c ‚Üî a = b := by
  rw [other_comm, @other_comm b, other_inj_left]

@[simp]
theorem other_isNext_left : ‚àÄ {a b}, (other a b).IsNext a ‚Üî a.IsNext b := by
  decide

@[simp]
theorem other_isNext_right : ‚àÄ {a b}, (other a b).IsNext b ‚Üî b.IsNext a := by
  decide

@[simp]
theorem isNext_other_left : ‚àÄ {a b}, IsNext a (other a b) ‚Üî b.IsNext a := by
  decide

@[simp]
theorem isNext_other_right : ‚àÄ {a b}, IsNext b (other a b) ‚Üî a.IsNext b := by
  decide

end Axis

/-- One of six possible orientations for a face of a Rubik's cube, represented as `Bool √ó Axis`.

We employ the convention that the sign argument is `true` for the front, right, and up orientations.

This type will also be used for the colors in a Rubik's cube, using the following convention:

* Red = Right
* White = Up
* Green = Front
* Orange = Left
* Yellow = Down
* Blue = Back
-/
def Orientation : Type := Bool √ó Axis

namespace Orientation

instance decEq : DecidableEq Orientation :=
  inferInstanceAs (DecidableEq (Bool √ó Axis))

instance : Repr Orientation := ‚ü®fun e _ ‚Ü¶ Std.Format.text <| match e with
  | (true, Axis.x) => "R"
  | (true, Axis.y) => "U"
  | (true, Axis.z) => "F"
  | (false, Axis.x) => "L"
  | (false, Axis.y) => "D"
  | (false, Axis.z) => "B"
‚ü©

/-- The color represented by an orientation, as a Unicode square. -/
def color : Orientation ‚Üí String
  | (true, Axis.x) => "üü•"
  | (true, Axis.y) => "‚¨ú"
  | (true, Axis.z) => "üü©"
  | (false, Axis.x) => "üüß"
  | (false, Axis.y) => "üü®"
  | (false, Axis.z) => "üü¶"

instance : HAppend Std.Format Orientation Std.Format :=
  ‚ü®fun s a ‚Ü¶ s ++ a.color‚ü©

instance instFintype : Fintype Orientation :=
  inferInstanceAs (Fintype (Bool √ó Axis))

protected theorem card : Fintype.card Orientation = 6 :=
  rfl

/-- Right orientation or red color. -/
def R : Orientation := (true, Axis.x)
/-- Up orientation or white color. -/
def U : Orientation := (true, Axis.y)
/-- Front orientation or green color. -/
def F : Orientation := (true, Axis.z)

/-- Left orientation or orange color. -/
def L : Orientation := (false, Axis.x)
/-- Down orientation or yellow color. -/
def D : Orientation := (false, Axis.y)
/-- Back orientation or blue color. -/
def B : Orientation := (false, Axis.z)

/-- The sign (positive or negative) corresponding to the orientation. -/
def sign (a : Orientation) : Bool :=
  a.1

@[simp]
theorem sign_mk (b : Bool) (a : Axis) : sign (b, a) = b :=
  rfl

/-- The Cartesian axis corresponding to the orientation. -/
def axis (a : Orientation) : Axis :=
  a.2

@[simp]
theorem axis_mk (b : Bool) (a : Axis) : axis (b, a) = a :=
  rfl

@[ext]
theorem ext (h‚ÇÅ : sign a = sign b) (h‚ÇÇ : axis a = axis b) : a = b :=
  Prod.ext h‚ÇÅ h‚ÇÇ

/-- The negative of an orientation. -/
instance : Neg Orientation :=
  ‚ü®fun a ‚Ü¶ (!a.1, a.2)‚ü©

instance : InvolutiveNeg Orientation :=
  ‚ü®fun _ ‚Ü¶ ext (Bool.not_not _) rfl‚ü©

@[simp]
theorem neg_mk (b : Bool) (a : Axis) : instNeg.neg (b, a) = (!b, a) :=
  rfl

@[simp]
theorem sign_neg (a : Orientation) : (-a).sign = !a.sign :=
  rfl

@[simp]
theorem axis_neg (a : Orientation) : (-a).axis = a.axis :=
  rfl

theorem eq_or_neg_of_eq_axis (h : axis a = axis b) : a = b ‚à® a = -b := by
  obtain hs | hs := Bool.eq_or_eq_not a.sign b.sign
  ¬∑ exact Or.inl (ext hs h)
  ¬∑ exact Or.inr (ext hs h)

/-- Two orientations are adjacent when they have distinct axes. -/
def IsAdjacent (a b : Orientation) : Prop :=
  a.axis ‚â† b.axis

instance IsAdjacent.decRel : DecidableRel IsAdjacent :=
  inferInstanceAs (‚àÄ a b : Orientation, Decidable (a.axis ‚â† b.axis))

@[simp]
theorem neg_isAdjacent : IsAdjacent (-a) b ‚Üî IsAdjacent a b :=
  Iff.rfl

@[simp]
theorem isAdjacent_neg : IsAdjacent a (-b) ‚Üî IsAdjacent a b :=
  Iff.rfl

theorem IsAdjacent.ne (h : IsAdjacent a b) : a ‚â† b := by
  rintro rfl
  exact h rfl

theorem isAdjacent_comm : IsAdjacent a b ‚Üî IsAdjacent b a :=
  ne_comm

alias ‚ü®IsAdjacent.swap, _‚ü© := isAdjacent_comm

/-- Given two adjacent orientations, returns the "cross product", i.e. the orientation `c` adjacent
to both, such that `(a, b, c)` is oriented as the standard basis. -/
def cross (a b : Orientation) : Orientation :=
  ((a.axis.IsNext b.axis) == (a.sign == b.sign), a.axis.other b.axis)

@[simp]
theorem sign_cross (a b : Orientation) :
    (cross a b).sign = ((a.axis.IsNext b.axis) == (a.sign == b.sign)) :=
  rfl

@[simp]
theorem axis_cross (a b : Orientation) : (cross a b).axis = a.axis.other b.axis :=
  rfl

theorem IsAdjacent.cross_left (h : IsAdjacent a b) : IsAdjacent (cross a b) a :=
  Axis.other_ne_left h

theorem IsAdjacent.cross_right (h : IsAdjacent a b) : IsAdjacent (cross a b) b :=
  Axis.other_ne_right h

@[simp]
theorem cross_neg_left : ‚àÄ (a b : Orientation), cross (-a) b = -cross a b := by
  decide

@[simp]
theorem cross_neg_right : ‚àÄ (a b : Orientation), cross a (-b) = -cross a b := by
  decide

theorem cross_asymm : ‚àÄ {a b}, IsAdjacent a b ‚Üí cross a b = - cross b a := by
  decide

@[simp]
theorem cross_inj_left : ‚àÄ {a b c}, cross a c = cross b c ‚Üî a = b := by
  decide

@[simp]
theorem cross_inj_right : ‚àÄ {a b c}, cross a b = cross a c ‚Üî b = c := by
  decide

@[simp]
theorem cross_cross_left : ‚àÄ (a b), cross (cross a b) a = b := by
  decide

@[simp]
theorem cross_cross_right : ‚àÄ (a b), cross b (cross a b) = a := by
  decide

theorem cross_cross_left' (h : IsAdjacent a b) : cross a (cross a b) = -b := by
  rw [cross_asymm h, cross_neg_right, cross_cross_right]

theorem cross_cross_right' (h : IsAdjacent a b) : cross (cross a b) b = -a := by
  rw [cross_asymm h, cross_neg_left, cross_cross_left]

/-- Take a piece with stickers on orientations `a ‚â† r`, and perform a **counterclockwise** rotation
in orientation `r`. This function returns the new orientation of the sticker with orientation `a`.

For instance, `rotate U F = L` since performing `F'` sends the upper-front corner to the left-front
one.

The reason this is inverted is so that
`(cube.rotate r).edge a b = Cube.edge (a.rotate r) (b.rotate r)`. -/
def rotate (a r : Orientation) : Orientation :=
  if r.axis = a.axis then a else cross r a

theorem rotate_of_eq {a r : Orientation} (h : r.axis = a.axis) : a.rotate r = a :=
  dif_pos h

theorem rotate_of_ne {a r : Orientation} (h : r.axis ‚â† a.axis) : a.rotate r = cross r a :=
  dif_neg h

@[simp]
theorem rotate_neg : rotate (-a) r = -rotate a r := by
  by_cases h : r.axis = a.axis
  ¬∑ rwa [rotate_of_eq h, rotate_of_eq]
  ¬∑ rwa [rotate_of_ne h, rotate_of_ne, cross_neg_right]

@[simp]
theorem rotate_inj : ‚àÄ {a b r}, rotate a r = rotate b r ‚Üî a = b := by
  decide

theorem isAdjacent_rotate : ‚àÄ {a b r : Orientation},
    IsAdjacent (a.rotate r) (b.rotate r) ‚Üî IsAdjacent a b := by
  decide

theorem IsAdjacent.rotate {a b : Orientation} (h : IsAdjacent a b) (r : Orientation) :
    IsAdjacent (a.rotate r) (b.rotate r) :=
  isAdjacent_rotate.2 h

/-- A predicate for three pairwise adjacent orientations, oriented as the standard basis.

The orientation condition is required, since it's not physically possible to exchange two pieces in
a corner without dissassembling it. -/
@[pp_nodot]
def IsAdjacent‚ÇÉ (a b c : Orientation) : Prop :=
  IsAdjacent a b ‚àß cross a b = c

instance IsAdjacent‚ÇÉ.decRel : ‚àÄ a b c, Decidable (IsAdjacent‚ÇÉ a b c) :=
  inferInstanceAs (‚àÄ a b c, Decidable (IsAdjacent a b ‚àß cross a b = c))

theorem IsAdjacent‚ÇÉ.isAdjacent (h : IsAdjacent‚ÇÉ a b c) : IsAdjacent a b :=
  h.1

theorem IsAdjacent.isAdjacent‚ÇÉ (h : IsAdjacent a b) : IsAdjacent‚ÇÉ a b (cross a b) :=
  ‚ü®h, rfl‚ü©

theorem IsAdjacent‚ÇÉ.congr (h‚ÇÅ : IsAdjacent‚ÇÉ a b c‚ÇÅ) (h‚ÇÇ : IsAdjacent‚ÇÉ a b c‚ÇÇ) : c‚ÇÅ = c‚ÇÇ :=
  h‚ÇÅ.2.symm.trans h‚ÇÇ.2

theorem isAdjacent‚ÇÉ_cyclic : IsAdjacent‚ÇÉ a b c ‚Üî IsAdjacent‚ÇÉ b c a := by
  constructor <;>
  rintro ‚ü®h, rfl‚ü©
  ¬∑ exact ‚ü®(h.cross_right).symm, cross_cross_right _ _‚ü©
  ¬∑ exact ‚ü®h.cross_left, cross_cross_left _ _‚ü©

alias ‚ü®IsAdjacent‚ÇÉ.cyclic, _‚ü© := isAdjacent‚ÇÉ_cyclic

theorem IsAdjacent‚ÇÉ.ne (h : IsAdjacent‚ÇÉ a b c) : a ‚â† b ‚àß b ‚â† c ‚àß c ‚â† a :=
  ‚ü®h.isAdjacent.ne, h.cyclic.isAdjacent.ne, h.cyclic.cyclic.isAdjacent.ne‚ü©

theorem cross_rotate : ‚àÄ {a b r : Orientation},
    IsAdjacent a b ‚Üí cross (a.rotate r) (b.rotate r) = (cross a b).rotate r := by
  decide

theorem isAdjacent‚ÇÉ_rotate {a b c r : Orientation} :
    IsAdjacent‚ÇÉ (a.rotate r) (b.rotate r) (c.rotate r) ‚Üî IsAdjacent‚ÇÉ a b c := by
  constructor
  ¬∑ rintro ‚ü®h, hr‚ü©
    have H := isAdjacent_rotate.1 h
    rw [cross_rotate H, rotate_inj] at hr
    exact ‚ü®H, hr‚ü©
  ¬∑ rintro ‚ü®h, rfl‚ü©
    exact ‚ü®h.rotate r, cross_rotate h‚ü©

theorem IsAdjacent‚ÇÉ.rotate {a b c : Orientation} (h : IsAdjacent‚ÇÉ a b c) (r : Orientation) :
    IsAdjacent‚ÇÉ (a.rotate r) (b.rotate r) (c.rotate r) :=
  isAdjacent‚ÇÉ_rotate.2 h

end Orientation

open Orientation

/-- An edge piece is an ordered pair of adjacent orientations.

Since we identify colors and orientations, there's two possible ways to think of this type:

- The position of an edge piece within a Rubik's cube, specified by its face, followed by its
  relative orientation with respect to it. For instance, `EdgePiece.mk U B _` is the upper piece in the upper-back edge.
- An edge piece with a particular color, within a particular edge. For instance,
  `EdgePiece.mk U B _` is the white piece of the white-blue edge.

The type `PRubik` contains an `EdgePiece ‚âÉ EdgePiece` field, which assigns to each position in the
cube a particular sticker color. -/
structure EdgePiece : Type where
  /-- The first and "distinguished" orientation in the edge piece. -/
  fst : Orientation
  /-- The second orientation in the edge piece. -/
  snd : Orientation
  /-- Both orientations are adjacent. -/
  isAdjacent : IsAdjacent fst snd

deriving instance DecidableEq, Fintype for EdgePiece

namespace EdgePiece

instance : Inhabited EdgePiece :=
  ‚ü®EdgePiece.mk U B (by decide)‚ü©

instance : Repr EdgePiece :=
  ‚ü®fun e ‚Ü¶ [e.fst, e.snd].repr‚ü©

protected theorem card : Fintype.card EdgePiece = 24 :=
  rfl

@[ext]
theorem ext {e‚ÇÅ e‚ÇÇ : EdgePiece} (hf : e‚ÇÅ.fst = e‚ÇÇ.fst) (hs : e‚ÇÅ.snd = e‚ÇÇ.snd) : e‚ÇÅ = e‚ÇÇ := by
  cases e‚ÇÅ
  cases e‚ÇÇ
  simpa using ‚ü®hf, hs‚ü©

/-- Builds an `EdgePiece`, automatically inferring the adjacency condition. -/
protected def mk' (a b : Orientation) (h : IsAdjacent a b := by decide) : EdgePiece :=
  EdgePiece.mk a b h

/-- Constructs the other edge piece sharing an edge. -/
def swap (e : EdgePiece) : EdgePiece :=
  ‚ü®_, _, e.isAdjacent.swap‚ü©

@[simp]
theorem swap_mk (h : IsAdjacent a b) : swap ‚ü®a, b, h‚ü© = ‚ü®b, a, h.swap‚ü© :=
  rfl

@[simp]
theorem swap_fst (e : EdgePiece) : e.swap.fst = e.snd :=
  rfl

@[simp]
theorem swap_snd (e : EdgePiece) : e.swap.snd = e.fst :=
  rfl

/-- Constructs the finset containing the edge's orientations. -/
def toFinset (e : EdgePiece) : Finset Orientation :=
  ‚ü®{e.fst, e.snd}, by simpa using e.isAdjacent.ne‚ü©

theorem card_toFinset (e : EdgePiece) : e.toFinset.card = 2 :=
  rfl

@[simp]
theorem swap_toFinset (e : EdgePiece) : e.swap.toFinset = e.toFinset := by
  rw [toFinset]
  simp_rw [Multiset.pair_comm]
  rfl

instance : Setoid EdgePiece where
  r e‚ÇÅ e‚ÇÇ := e‚ÇÅ.toFinset = e‚ÇÇ.toFinset
  iseqv := by
    constructor
    ¬∑ exact fun x ‚Ü¶ rfl
    ¬∑ exact Eq.symm
    ¬∑ exact Eq.trans

instance : DecidableRel (Œ± := EdgePiece) (¬∑ ‚âà ¬∑) :=
  fun e‚ÇÅ e‚ÇÇ ‚Ü¶ inferInstanceAs (Decidable (e‚ÇÅ.toFinset = e‚ÇÇ.toFinset))

end EdgePiece

/-- An edge is the equivalence class of edge pieces sharing an edge. -/
def Edge : Type := Quotient EdgePiece.instSetoid

namespace Edge

@[simp]
theorem mk_swap (e : EdgePiece) : (‚ü¶e.swap‚üß : Edge) = ‚ü¶e‚üß :=
  Quotient.sound e.swap_toFinset

instance : Fintype Edge :=
  Quotient.fintype _

protected theorem card : Fintype.card Edge = 12 :=
  rfl

end Edge

/-- A corner piece is an ordered triple of pairwise adjacent orientations, oriented as the standard
basis.

Since we identify colors and orientations, there's two possible ways to think of this type:

- The position of a corner piece within a Rubik's cube, specified by its face, followed by its
  relative orientation with respect to it. For instance, `EdgePiece.mk U B L _` is the upper piece
  in the upper-back-left corner.
- A corner piece with a particular color, within a particular corner. For instance,
  `EdgePiece.mk U B L _` is the white piece of the white-blue-orange edge.

The type `PRubik` contains an `CornerPiece ‚âÉ CornerPiece` field, which assigns to each position in
the cube a particular sticker color. -/
structure CornerPiece : Type where
  /-- The first and "distinguished" orientation in the corner piece. -/
  fst : Orientation
  /-- The second orientation in the corner piece. -/
  snd : Orientation
  /-- The third orientation in the corner piece. This is actually completely determined from the
  other two, but we still define it for symmetry. -/
  thd : Orientation
  /-- All orientations are adjacent, and form a positively oriented basis. -/
  isAdjacent‚ÇÉ : IsAdjacent‚ÇÉ fst snd thd

deriving instance DecidableEq for CornerPiece

/-- Builds a corner from pairwise isAdjacent orientations. -/
def Orientation.IsAdjacent‚ÇÉ.toCornerPiece (h : IsAdjacent‚ÇÉ a b c) : CornerPiece :=
  CornerPiece.mk a b c h

@[ext]
theorem CornerPiece.ext {c‚ÇÅ c‚ÇÇ : CornerPiece}
    (hf : c‚ÇÅ.fst = c‚ÇÇ.fst) (hs : c‚ÇÅ.snd = c‚ÇÇ.snd) : c‚ÇÅ = c‚ÇÇ := by
  obtain ‚ü®f‚ÇÅ, s‚ÇÅ, t‚ÇÅ, h‚ÇÅ‚ü© := c‚ÇÅ
  obtain ‚ü®f‚ÇÇ, s‚ÇÇ, t‚ÇÇ, h‚ÇÇ‚ü© := c‚ÇÇ
  dsimp at *
  subst hf hs
  simpa using h‚ÇÅ.congr h‚ÇÇ

/-- Edge pieces and corner pieces can be put in bijection. -/
def EdgeCornerEquiv : EdgePiece ‚âÉ CornerPiece where
  toFun e := ‚ü®_, _, _, e.isAdjacent.isAdjacent‚ÇÉ‚ü©
  invFun c := ‚ü®_, _, c.isAdjacent‚ÇÉ.isAdjacent‚ü©
  left_inv _ := rfl
  right_inv c := by ext <;> rfl

namespace CornerPiece

instance : Inhabited CornerPiece :=
  ‚ü®CornerPiece.mk U B L (by decide)‚ü©

instance : Repr CornerPiece :=
  ‚ü®fun c ‚Ü¶ [c.fst, c.snd, c.thd].repr‚ü©

instance : Fintype CornerPiece :=
  Fintype.ofEquiv _ EdgeCornerEquiv

protected theorem card : Fintype.card CornerPiece = 24 :=
  rfl

/-- Permutes the colors in a corner cyclically. -/
def cyclic (c : CornerPiece) : CornerPiece :=
  c.isAdjacent‚ÇÉ.cyclic.toCornerPiece

@[simp]
theorem cyclic_mk (h : IsAdjacent‚ÇÉ a b c) : cyclic ‚ü®a, b, c, h‚ü© = ‚ü®b, c, a, h.cyclic‚ü© :=
  rfl

@[simp]
theorem cyclic_fst (c : CornerPiece) : c.cyclic.fst = c.snd :=
  rfl

@[simp]
theorem cyclic_snd (c : CornerPiece) : c.cyclic.snd = c.thd :=
  rfl

@[simp]
theorem cyclic_thd (c : CornerPiece) : c.cyclic.thd = c.fst :=
  rfl

/-- Constructs the finset containing the corner's orientations. -/
def toFinset (e : CornerPiece) : Finset Orientation :=
  ‚ü®{e.fst, e.snd, e.thd}, by
    obtain ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := e.isAdjacent‚ÇÉ.ne
    simpa using ‚ü®‚ü®h‚ÇÅ, h‚ÇÉ.symm‚ü©, h‚ÇÇ‚ü©‚ü©

theorem card_toFinset (c : CornerPiece) : c.toFinset.card = 3 :=
  rfl

@[simp]
theorem cyclic_toFinset (c : CornerPiece) : c.cyclic.toFinset = c.toFinset := by
  have : ‚àÄ a b c : Orientation, ({a, b, c} : Multiset _) = {c, a, b} := by
    decide
  simp_rw [toFinset, cyclic, IsAdjacent‚ÇÉ.toCornerPiece, this]

instance : Setoid CornerPiece where
  r c‚ÇÅ c‚ÇÇ := c‚ÇÅ.toFinset = c‚ÇÇ.toFinset
  iseqv := by
    constructor
    ¬∑ exact fun x ‚Ü¶ rfl
    ¬∑ exact Eq.symm
    ¬∑ exact Eq.trans

instance : DecidableRel (Œ± := CornerPiece) (¬∑ ‚âà ¬∑) :=
  fun c‚ÇÅ c‚ÇÇ ‚Ü¶ inferInstanceAs (Decidable (c‚ÇÅ.toFinset = c‚ÇÇ.toFinset))

end CornerPiece

/-- A corner is the equivalence class of corner pieces sharing a corner. -/
def Corner : Type := Quotient CornerPiece.instSetoid

namespace Corner

@[simp]
theorem mk_cyclic (c : CornerPiece) : (‚ü¶c.cyclic‚üß : Corner) = ‚ü¶c‚üß :=
  Quotient.sound c.cyclic_toFinset

instance : Fintype Corner :=
  Quotient.fintype _

protected theorem card : Fintype.card Corner = 8 :=
  rfl

end Corner

/-- A pre-Rubik's cube. We represent this as a permutation of the edge pieces, and a permutation of
the corner pieces, such that pieces in the same edge or corner get mapped to the same edge or
corner.

This can be thought as the type of Rubik's cubes that can be physically assembled, without regard
for the solvability invariants. -/
structure PRubik : Type where
  /-- Returns the edge piece at a given location. -/
  edgePieceEquiv : EdgePiece ‚âÉ EdgePiece
  /-- Returns the corner piece at a given location. -/
  cornerPieceEquiv : CornerPiece ‚âÉ CornerPiece
  /-- Pieces in the same edge get mapped to pieces in the same edge. -/
  edge_swap (e : EdgePiece) : edgePieceEquiv e.swap = (edgePieceEquiv e).swap
  /-- Pieces in the same corner get mapped to pieces in the same corner. -/
  corner_cyclic (c : CornerPiece) : cornerPieceEquiv c.cyclic = (cornerPieceEquiv c).cyclic

attribute [simp] PRubik.edge_swap PRubik.corner_cyclic

namespace PRubik

deriving instance DecidableEq, Fintype for PRubik

@[ext]
theorem ext (cube‚ÇÅ cube‚ÇÇ : PRubik)
    (he : ‚àÄ e, cube‚ÇÅ.edgePieceEquiv e = cube‚ÇÇ.edgePieceEquiv e)
    (hc : ‚àÄ c, cube‚ÇÅ.cornerPieceEquiv c = cube‚ÇÇ.cornerPieceEquiv c) :
    cube‚ÇÅ = cube‚ÇÇ := by
  obtain ‚ü®e‚ÇÅ, c‚ÇÅ, _, _‚ü© := cube‚ÇÅ
  obtain ‚ü®e‚ÇÇ, c‚ÇÇ, _, _‚ü© := cube‚ÇÇ
  simp
  rw [Equiv.ext_iff, Equiv.ext_iff]
  exact ‚ü®he, hc‚ü©

/-- An auxiliary function to get an edge piece in a cube, inferring the adjacency hypothesis. -/
def edgePiece (cube : PRubik) (a b : Orientation) (h : IsAdjacent a b := by decide) : EdgePiece :=
  cube.edgePieceEquiv (EdgePiece.mk a b h)

/-- An auxiliary function to get a corner piece in a cube, inferring the adjacency hypothesis. -/
def cornerPiece (cube : PRubik) (a b c : Orientation) (h : IsAdjacent‚ÇÉ a b c := by decide) :
    CornerPiece :=
  cube.cornerPieceEquiv (CornerPiece.mk a b c h)

/-- A list with all non-equivalent edges. This is an auxiliary function for the `PRubik.Repr` instance. -/
private def edges : List EdgePiece :=
  [EdgePiece.mk' U B, EdgePiece.mk' U L, EdgePiece.mk' U R, EdgePiece.mk' U F,
    EdgePiece.mk' L B, EdgePiece.mk' L F, EdgePiece.mk' F R, EdgePiece.mk' R B,
    EdgePiece.mk' D B, EdgePiece.mk' D L, EdgePiece.mk' D R, EdgePiece.mk' D F]

/-- The corners in a Rubik's cube. This is an auxiliary function for the `Repr` instance. -/
private def corners (cube : PRubik) : List CornerPiece :=
  [cube.cornerPiece U B L, cube.cornerPiece U R B, cube.cornerPiece U L F, cube.cornerPiece U F R,
    cube.cornerPiece D L B, cube.cornerPiece D B R, cube.cornerPiece D F L, cube.cornerPiece D R F]

open Std.Format in
instance : Repr PRubik := ‚ü®fun cube _ ‚Ü¶
  let e := edges.map cube.edgePieceEquiv
  let c := cube.corners
  have : e.length = 12 := rfl
  have : c.length = 8 := rfl
  let space := text "‚¨õ‚¨õ‚¨õ"
  -- Up face
  space ++ c[0].fst ++ e[0].fst ++ c[1].fst ++ space ++ line
    ++ space ++ e[1].fst ++ U ++ e[2].fst ++ space ++ line
    ++ space ++ c[2].fst ++ e[3].fst ++ c[3].fst ++ space ++ line
  -- Left, front, and right faces
  ++ c[0].thd ++ e[1].snd ++ c[2].snd ++ c[2].thd ++ e[3].snd ++
    c[3].snd ++ c[3].thd ++ e[2].snd ++ c[1].snd ++ line
  ++ e[4].fst ++ L ++ e[5].fst ++ e[5].snd ++ F ++ e[6].fst ++ e[6].snd ++ R ++ e[7].fst ++ line
  ++ c[4].snd ++ e[9].snd ++ c[6].thd ++ c[6].snd ++ e[11].snd ++
    c[7].thd ++ c[7].snd ++ e[10].snd ++ c[5].thd ++ line
  -- Down face
  ++ space ++ c[6].fst ++ e[11].fst ++ c[7].fst ++ space ++ line
    ++ space ++ e[9].fst ++ D ++ e[10].fst ++ space ++ line
    ++ space ++ c[4].fst ++ e[8].fst ++ c[5].fst ++ space ++ line
  -- Back face
  ++ space ++ c[4].thd ++ e[8].snd ++ c[5].snd ++ space ++ line
    ++ space ++ e[4].snd ++ B ++ e[7].snd ++ space ++ line
    ++ space ++ c[0].snd ++ e[0].snd ++ c[1].thd ++ space‚ü©

/-- A solved Rubik's cube. -/
@[simps]
protected def id : PRubik where
  edgePieceEquiv := Equiv.refl _
  cornerPieceEquiv := Equiv.refl _
  edge_swap _ := rfl
  corner_cyclic _ := rfl

instance : Inhabited PRubik := ‚ü®PRubik.id‚ü©

/-- The composition of two Rubik's cubes is the Rubik's cube where the second's scramble is
performed after the first's.

Note that this is opposite to the usual convention for function composition. -/
@[simps]
protected def trans (cube‚ÇÅ cube‚ÇÇ : PRubik) : PRubik where
  edgePieceEquiv := cube‚ÇÇ.edgePieceEquiv.trans cube‚ÇÅ.edgePieceEquiv
  cornerPieceEquiv := cube‚ÇÇ.cornerPieceEquiv.trans cube‚ÇÅ.cornerPieceEquiv
  edge_swap _ := by
    dsimp
    rw [cube‚ÇÇ.edge_swap, cube‚ÇÅ.edge_swap]
  corner_cyclic _ := by
    dsimp
    rw [cube‚ÇÇ.corner_cyclic, cube‚ÇÅ.corner_cyclic]

@[simp]
theorem id_trans (cube : PRubik) : PRubik.id.trans cube = cube := by
  apply PRubik.ext <;>
  intros <;>
  rfl

@[simp]
theorem trans_id (cube : PRubik) : cube.trans PRubik.id = cube := by
  apply PRubik.ext <;>
  intros <;>
  rfl

theorem trans_assoc (cube‚ÇÅ cube‚ÇÇ cube‚ÇÉ : PRubik) :
    (cube‚ÇÅ.trans cube‚ÇÇ).trans cube‚ÇÉ = cube‚ÇÅ.trans (cube‚ÇÇ.trans cube‚ÇÉ) := by
  apply PRubik.ext <;>
  intros <;>
  rfl

/-- The inverse of a Rubik's cube is obtained -/
@[simps]
protected def symm (cube : PRubik) : PRubik where
  edgePieceEquiv := cube.edgePieceEquiv.symm
  cornerPieceEquiv := cube.cornerPieceEquiv.symm
  edge_swap e := by
    conv_rhs => rw [‚Üê cube.edgePieceEquiv.symm_apply_apply (EdgePiece.swap _)]
    rw [cube.edge_swap, Equiv.apply_symm_apply]
  corner_cyclic e := by
    conv_rhs => rw [‚Üê cube.cornerPieceEquiv.symm_apply_apply (CornerPiece.cyclic _)]
    rw [cube.corner_cyclic, Equiv.apply_symm_apply]

@[simp]
theorem trans_symm (cube : PRubik) : cube.trans cube.symm = PRubik.id := by
  apply PRubik.ext <;>
  intros <;>
  simp

@[simp]
theorem symm_trans (cube : PRubik) : cube.symm.trans cube = PRubik.id := by
  apply PRubik.ext <;>
  intros <;>
  simp

/-- The "pre-Rubik's cube" group. This isn't the true Rubik's cube group as it contains positions
that are unreachable by valid moves. -/
instance : Group PRubik where
  one := PRubik.id
  mul := PRubik.trans
  mul_assoc := trans_assoc
  one_mul := id_trans
  mul_one := trans_id
  inv := PRubik.symm
  inv_mul_cancel := symm_trans

/-- Applies a **counterclockwise** rotation to an edge piece. -/
private def rotate_edgePiece (r : Orientation) : EdgePiece ‚Üí EdgePiece :=
  fun e ‚Ü¶ if r ‚àà e.toFinset then ‚ü®_, _, e.isAdjacent.rotate r‚ü© else e

theorem rotate_edgePiece‚ÇÑ : ‚àÄ r : Orientation, (rotate_edgePiece r)^[4] = id := by
  decide

/-- Applies a **counterclockwise** rotation to a corner piece. -/
private def rotate_cornerPiece (r : Orientation) : CornerPiece ‚Üí CornerPiece :=
  fun c ‚Ü¶ if r ‚àà c.toFinset then ‚ü®_, _, _, c.isAdjacent‚ÇÉ.rotate r‚ü© else c

theorem rotate_cornerPiece‚ÇÑ : ‚àÄ r : Orientation, (rotate_cornerPiece r)^[4] = id := by
  decide

/-- Defines the Rubik's cube where only a single **clockwise** move in a given orientation is
performed. -/
def ofOrientation (r : Orientation) : PRubik where
  edgePieceEquiv := ‚ü®
      rotate_edgePiece r,
      (rotate_edgePiece r)^[3],
      funext_iff.1 (rotate_edgePiece‚ÇÑ r),
      funext_iff.1 (rotate_edgePiece‚ÇÑ r)‚ü©
  cornerPieceEquiv := ‚ü®
      rotate_cornerPiece r,
      (rotate_cornerPiece r)^[3],
      funext_iff.1 (rotate_cornerPiece‚ÇÑ r),
      funext_iff.1 (rotate_cornerPiece‚ÇÑ r)‚ü©
  edge_swap e := by
    dsimp
    simp_rw [rotate_edgePiece, EdgePiece.swap_toFinset]
    split <;>
    rfl
  corner_cyclic c := by
    dsimp
    simp_rw [rotate_cornerPiece, CornerPiece.cyclic_toFinset]
    split <;>
    rfl

/-- Applies a clockwise rotation to a Rubik's cube. -/
def rotate (cube : PRubik) (r : Orientation) : PRubik :=
  cube.trans (ofOrientation r)

end PRubik

/-- A sequence of moves to be applied to a Rubik's cube. -/
def Moves : Type := List Orientation

namespace Moves

instance : EmptyCollection Moves :=
  inferInstanceAs (EmptyCollection (List Orientation))

instance : Append Moves :=
  inferInstanceAs (Append (List Orientation))

/-- Turn right face. -/
def R : Moves := [Orientation.R]
/-- Turn up face. -/
def U : Moves := [Orientation.U]
/-- Turn front face. -/
def F : Moves := [Orientation.F]

/-- Turn left face. -/
def L : Moves := [Orientation.L]
/-- Turn down face. -/
def D : Moves := [Orientation.D]
/-- Turn back face. -/
def B : Moves := [Orientation.D]

/-- Turn right face twice. -/
def R2 : Moves := R ++ R
/-- Turn up face twice. -/
def U2 : Moves := U ++ U
/-- Turn front face twice. -/
def F2 : Moves := F ++ F

/-- Turn left face twice. -/
def L2 : Moves := L ++ L
/-- Turn down face twice. -/
def D2 : Moves := D ++ D
/-- Turn back face twice. -/
def B2 : Moves := B ++ B

/-- Turn right face backwards. -/
def R' : Moves := R2 ++ R
/-- Turn up face backwards. -/
def U' : Moves := U2 ++ U
/-- Turn front face backwards. -/
def F' : Moves := F2 ++ F

/-- Turn left face backwards. -/
def L' : Moves := L2 ++ L
/-- Turn down face backwards. -/
def D' : Moves := D2 ++ D
/-- Turn back face backwards. -/
def B' : Moves := B2 ++ B

end Moves

namespace PRubik

/-- Applies a sequence of moves to a Rubik's cube. -/
def move (cube : PRubik) (m : Moves) : PRubik :=
  m.foldl PRubik.rotate cube

theorem move_append (cube : PRubik) (m n : Moves) : cube.move (m ++ n) = (cube.move m).move n :=
  List.foldl_append _ _ _ _

end PRubik

#eval PRubik.id.move [U, R, R, F, B, R, B, B, R, U, U, L, B, B, R, U, U, U, D, D, D, R, R,
  F, R, R, R, L, B, B, U, U, F, F]
